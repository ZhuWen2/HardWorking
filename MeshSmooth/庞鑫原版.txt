#include "MeshSmooth.h"

#include <minmax.h>
#include <algorithm>

void DihedralEnergy::compute_angles(const myMesh & m, myMesh::HalfedgeHandle h) const
{
	myMesh::HalfedgeHandle eh = m.opposite_halfedge_handle(h);
	myMesh::VertexHandle hv = m.to_vertex_handle(h);
	myMesh::VertexHandle hov = m.to_vertex_handle(eh);
	myMesh::VertexHandle hnv = m.to_vertex_handle(m.next_halfedge_handle(h));
	myMesh::VertexHandle honv = m.to_vertex_handle(m.next_halfedge_handle(eh));

	OpenMesh::Vec3d va(m.point(hv));
	OpenMesh::Vec3d vb(m.point(hov));
	OpenMesh::Vec3d vc(m.point(hnv));
	OpenMesh::Vec3d vd(m.point(honv));

	myMesh::FaceHandle fa = m.face_handle(m.opposite_halfedge_handle(m.next_halfedge_handle(h)));
	myMesh::FaceHandle fb = m.face_handle(m.opposite_halfedge_handle(m.next_halfedge_handle(m.next_halfedge_handle(h))));
	myMesh::FaceHandle fc = m.face_handle(m.opposite_halfedge_handle(m.next_halfedge_handle(eh)));
	myMesh::FaceHandle fd = m.face_handle(m.opposite_halfedge_handle(m.next_halfedge_handle(m.next_halfedge_handle(eh))));

	OpenMesh::Vec3d n1 = OpenMesh::cross(vc - va, vb - va).normalize();
	OpenMesh::Vec3d n2 = OpenMesh::cross(vb - va, vd - va).normalize();

	OpenMesh::Vec3d na = !m.is_valid_handle(fa) ? OpenMesh::Vec3d(0.0) : OpenMesh::Vec3d(m.normal(fa));
	OpenMesh::Vec3d nb = !m.is_valid_handle(fb) ? OpenMesh::Vec3d(0.0) : OpenMesh::Vec3d(m.normal(fb));
	OpenMesh::Vec3d nc = !m.is_valid_handle(fc) ? OpenMesh::Vec3d(0.0) : OpenMesh::Vec3d(m.normal(fc));
	OpenMesh::Vec3d nd = !m.is_valid_handle(fd) ? OpenMesh::Vec3d(0.0) : OpenMesh::Vec3d(m.normal(fd));

	OpenMesh::Vec3d fn1 = OpenMesh::cross(vb - vc, vd - vc).normalize();
	OpenMesh::Vec3d fn2 = OpenMesh::cross(vd - vc, va - vc).normalize();

	ab_12 = cos_ang(n1, n2);
	ab_a1 = cos_ang(na, n1);
	ab_b1 = cos_ang(nb, n1);
	ab_2c = cos_ang(n2, nc);
	ab_2d = cos_ang(n2, nd);

	aa_12 = cos_ang(fn1, fn2);
	aa_b1 = cos_ang(nb, fn1);
	aa_c1 = cos_ang(nc, fn1);
	aa_2a = cos_ang(fn2, na);
	aa_2d = cos_ang(fn2, nd);
}

double DihedralEnergy::energy(const myMesh & m, myMesh::HalfedgeHandle h) const
{
	myMesh::FaceHandle hf = m.face_handle(h);
	myMesh::FaceHandle hof = m.face_handle(m.opposite_halfedge_handle(h));

	double a = cos_ang(OpenMesh::Vec3d(m.normal(hf)), OpenMesh::Vec3d(m.normal(hof)));

	myMesh::VertexHandle hv = m.to_vertex_handle(h);
	myMesh::VertexHandle hov = m.to_vertex_handle(m.opposite_halfedge_handle(h));

	OpenMesh::Vec3d va(m.point(hv));
	OpenMesh::Vec3d vb(m.point(hov));

	if (use_alpha)
		return edge_alpha_energy(va, vb, a);

	return edge_c_energy(va, vb, a);
}

double DihedralEnergy::delta_energy(const myMesh & m, myMesh::HalfedgeHandle h) const
{
	compute_angles(m, h);

	myMesh::HalfedgeHandle eh = m.opposite_halfedge_handle(h);
	myMesh::VertexHandle hv = m.to_vertex_handle(h);
	myMesh::VertexHandle hov = m.to_vertex_handle(eh);
	myMesh::VertexHandle hnv = m.to_vertex_handle(m.next_halfedge_handle(h));
	myMesh::VertexHandle honv = m.to_vertex_handle(m.next_halfedge_handle(eh));

	OpenMesh::Vec3d va(m.point(hv));
	OpenMesh::Vec3d vb(m.point(hov));
	OpenMesh::Vec3d vc(m.point(hnv));
	OpenMesh::Vec3d vd(m.point(honv));

	if (use_alpha) {
		double before =
			edge_alpha_energy(va, vb, ab_12)
			+ edge_alpha_energy(va, vc, ab_a1)
			+ edge_alpha_energy(vc, vb, ab_b1)
			+ edge_alpha_energy(vd, vb, ab_2c)
			+ edge_alpha_energy(vd, va, ab_2d);

		double after =
			edge_alpha_energy(vd, vc, aa_12)
			+ edge_alpha_energy(vb, vc, aa_b1)
			+ edge_alpha_energy(vd, vb, aa_c1)
			+ edge_alpha_energy(va, vc, aa_2a)
			+ edge_alpha_energy(vd, va, aa_2d);

		return (after - before);
	}
	double before =
		edge_c_energy(va, vb, ab_12)
		+ edge_c_energy(va, vc, ab_a1)
		+ edge_c_energy(vc, vb, ab_b1)
		+ edge_c_energy(vd, vb, ab_2c)
		+ edge_c_energy(vd, va, ab_2d);

	double after =
		edge_c_energy(vd, vc, aa_12)
		+ edge_c_energy(vb, vc, aa_b1)
		+ edge_c_energy(vd, vb, aa_c1)
		+ edge_c_energy(va, vc, aa_2a)
		+ edge_c_energy(vd, va, aa_2d);

	return after - before;
}


void GELSmooth::denoise(myMesh &mesh, int max_iter)
{	
	//这个函数是一共迭代max_iter次，每次先用GELSmoothFilter进行双边滤波把每个面的法线调整好
	//并保存在filter_normals中。然后调整点的位置，包括10次迭代，每次迭代中利用半边迭代将每个
	//半边的出发点都操作一遍，这样就能保证每个顶点被操作的次数是它相邻面的个数。
	//最后再把mesh中所有顶点遍历一遍，将刚才计算过的每个顶点的位置信息除以其操作的次数
	//就得到了平均的位置信息npos，最后把此顶点调整到npos位置上。这就是此函数的工作。
	double avg_len = 0.0;//边平均长度

	int e_it = 0, e_size = mesh.n_edges();
#pragma omp parallel for default(shared) reduction(+:avg_len)
	for (e_it = 0; e_it < e_size; ++e_it)
	{
		avg_len += mesh.calc_edge_length(myMesh::EdgeHandle(e_it));//为什么把所有的边长度加一起
	}

	std::vector<myMesh::Normal> filter_normals;
	filter_normals.resize(mesh.n_faces(), myMesh::Normal(0.0));
	for (int iter = 0; iter < max_iter; ++iter)//迭代max_iter次
	{
		int f_it = 0, f_size = mesh.n_faces();//一共有几个面
#pragma omp parallel for
		for (f_it = 0; f_it < f_size; ++f_it)//循环f_size次
		{
			filter_normals[f_it] = GELSmoothFilter(mesh, myMesh::FaceHandle(f_it), avg_len);//计算每个面的双边滤波后的法线。
		}

		std::vector<myMesh::Point> vertex_positions(mesh.n_vertices(), myMesh::Point(0.0));
		std::vector<int> count(mesh.n_vertices(), 0);
		for (int sub_iter = 0; sub_iter < 10; ++sub_iter)//为什么是10次循环
		{	
			//每次遍历所有半边，根据每个半边的面法线和此半边的关系调整此半边的出发顶点，
			//并记录每个顶点操作了几次
			//下面的for循环遍历每个半边，每个面里有三个半边，最后每个顶点被操作的次数就是顶点相邻的面的个数
			for (myMesh::HalfedgeIter he_it = mesh.halfedges_begin(); he_it != mesh.halfedges_end(); ++he_it)
			{
				myMesh::FaceHandle fh = mesh.face_handle(*he_it);
				if (fh.is_valid())
				{
					myMesh::VertexHandle vh = mesh.from_vertex_handle(*he_it);
					//std::cout << vh << std::endl;
					myMesh::Normal dir = mesh.point(mesh.to_vertex_handle(*he_it)) - mesh.point(vh);
					myMesh::Normal n = filter_normals[fh.idx()];
					vertex_positions[vh.idx()] += mesh.point(vh) + 0.5 * n * OpenMesh::dot(n, dir);
					count[vh.idx()] += 1;//记录每个顶点操作了几次，最后应该次数是顶点相邻的面的个数。
				}
			}

			double max_move = 0;
			int v_it = 0, v_size = mesh.n_vertices();//顶点的个数
#pragma omp parallel for//下面的循环把上面算出来的vertex_positions除以count[v_it]得到平均的位置npos，
						//并调整到npos位置上。
			for (v_it = 0; v_it < v_size; ++v_it)//循环v_size次
			{
				myMesh::Point npos;
				int j = v_it;
				if (count[j] == 0)//为什么会有顶点没被操作过？
					npos = mesh.point(myMesh::VertexHandle(v_it));
				else
				{
					npos = vertex_positions[v_it] / double(count[v_it]);
					myMesh::Point a = npos - mesh.point(myMesh::VertexHandle(v_it));
					double move = OpenMesh::dot(a, a);

					//#pragma omp critical
					if (move > max_move)
						max_move = move;

				}
				mesh.set_point(myMesh::VertexHandle(v_it), npos);//把v_it所在顶点调整到npos的位置上去
			}
			//如果最大的移动距离都已经小于阈值，就不用再调整了，直接break推出循环。
			if (max_move < (1e-8*avg_len)*(1e-8*avg_len))
			{
				break;
			}
		}

		mesh.update_face_normals();//计算面法线信息
	}
}

myMesh::Normal GELSmooth::GELSmoothFilter(myMesh & mesh, myMesh::FaceHandle fh, double avg_len)
{
	//此函数是把索引为fh的这个面的邻接面找出来然后遍历邻接面并利用这些邻接面的信息代入到双边滤波公式中，最后得到双边滤波完的此面的法向量。
	myMesh::Normal filter_normal = myMesh::Normal(0.0, 0.0, 0.0);
	std::vector<myMesh::FaceHandle> face_neighbor;
	getFaceNeighbor(mesh, fh, face_neighbor, true);
	myMesh::Point  pi = mesh.calc_face_centroid(fh);//计算面中心点
	myMesh::Normal ni = mesh.calc_face_normal(fh);//计算面法线
	//遍历这些邻面
	for (int i = 0; i < face_neighbor.size(); ++i)
	{
		myMesh::FaceHandle f = face_neighbor[i];
		myMesh::Normal nj = mesh.calc_face_normal(f);
		myMesh::Point  pj = mesh.calc_face_centroid(f);
		//下面是计算Wa和Ws，就是双边法向滤波里的两个高斯函数。
		double w_a = std::exp(-std::acos(max(-1.0, min(1.0, OpenMesh::dot(nj, ni)))) / (M_PI / 32));
		double w_s = std::exp(-(pj - pi).length() / avg_len);

		myMesh::Point face_vertices[3];
		int j = 0;
		//用循环器遍历这个面的顶点
		for (myMesh::FaceVertexIter fv_it = mesh.fv_begin(f); fv_it.is_valid(); ++fv_it)
		{
			face_vertices[j++] = mesh.point(*fv_it);//把这个面的三个顶点放到face_vertices里
		}
		myMesh::Normal e1 = face_vertices[1] - face_vertices[0];
		myMesh::Normal e2 = face_vertices[2] - face_vertices[0];//这是计算两条边e1,e2
		double area = 0.5 * OpenMesh::cross(e1, e2).length();//计算这个面的面积
		filter_normal += area * w_a*w_s*nj;//这是双边滤波公式，先求和，最后归一化。
	}
	return filter_normal.normalize();//归一化？
}

void GELSmooth::getFaceNeighbor(myMesh & mesh, myMesh::FaceHandle fh, std::vector<myMesh::FaceHandle>& face_neighbor, bool is_include_self)
{
	face_neighbor.clear();
	if (is_include_self)//如果传进来的是true，那么就包括传进来的面mesh本身，把其索引fh放进容器。
	{
		face_neighbor.push_back(fh);
	}
	//问题：下面这两层循环是否和FaceFaceIter循环器是一个作用？
	//接下来用循环器循环每个面的顶点
	for (myMesh::FaceVertexIter fv_it = mesh.fv_begin(fh); fv_it.is_valid(); ++fv_it)
	{
		//下面这个循环是用循环器循环每个顶点邻域的面
		for (myMesh::VertexFaceIter vf_it = mesh.vf_iter(*fv_it); vf_it.is_valid(); ++vf_it)
		{
			if ((*vf_it) != fh)//如果不是传进来的fh这个面，就把它push到face_neighbor中。
				face_neighbor.push_back(*vf_it);
		}
	}
	//std::unique函数的作用是“去除”容器或者数组中相邻元素的重复出现的元素，注意 
	//(1) 这里的去除并非真正意义的erase，而是将重复的元素放到容器的末尾，返回值是去重之后的尾地址。
	//(2) unique针对的是相邻元素，所以对于顺序顺序错乱的数组成员，或者容器成员，需要先进行排序，可以调用std::sort()函数
	std::sort(face_neighbor.begin(), face_neighbor.end());//升序排序
	face_neighbor.erase(std::unique(face_neighbor.begin(), face_neighbor.end()), face_neighbor.end());
	//所以这个意思是把std::unique返回的尾地址直到face_neighbor.end()给删除掉。
	
}

void GELSmooth::optimize_mesh(myMesh& m)
{
	DihedralEnergy efun(4.0, true);
	priority_queue_optimization(m, efun);
}

void GELSmooth::priority_queue_optimization(myMesh & m, const EnergyFun & efun)
{
	std::vector<HalfEdgeCounter> counter(m.n_halfedges(), HalfEdgeCounter{ 0, false });
	std::vector<int> flipCounter(m.n_vertices(), 0);
	std::priority_queue<PQElement> Q;

	int time = 1;
	for (myMesh::HalfedgeIter he_it = m.halfedges_begin(); he_it != m.halfedges_end(); ++he_it)
	{
		if (!counter[he_it->idx()].touched) {
			add_to_queue(m, counter, Q, *he_it, efun, flipCounter, time);
		}
	}

	while (!Q.empty())
	{
		PQElement elem = Q.top();
		Q.pop();

		if (counter[elem.h.idx()].isRemovedFromQueue)
			continue;
		counter[elem.h.idx()].isRemovedFromQueue = true;

		if (counter[elem.h.idx()].touched != elem.time)
			continue;

		if (efun.delta_energy(m, elem.h) >= -0.001)
			continue;

		if (!m.is_flip_ok(m.edge_handle(elem.h)))
			continue;

		flipCounter[m.to_vertex_handle(elem.h).idx()]++;

		m.flip(m.edge_handle(elem.h));

		add_one_ring_to_queue(m, counter, Q, m.to_vertex_handle(elem.h), efun, flipCounter, time);
		add_one_ring_to_queue(m, counter, Q, m.to_vertex_handle(m.next_halfedge_handle(elem.h)), efun, flipCounter, time);
		add_one_ring_to_queue(m, counter, Q, m.to_vertex_handle(m.opposite_halfedge_handle(elem.h)), efun, flipCounter, time);
		add_one_ring_to_queue(m, counter, Q, m.to_vertex_handle(m.next_halfedge_handle(m.opposite_halfedge_handle(elem.h))), efun, flipCounter, time);
	}

}

void GELSmooth::add_to_queue(const myMesh & m, std::vector<HalfEdgeCounter>& counter, std::priority_queue<PQElement>& Q, myMesh::HalfedgeHandle h, const EnergyFun & efun, std::vector<int>& flipCounter, int time)
{
	if (m.is_boundary(h))
		return;

	if (m.to_vertex_handle(h).idx() < m.from_vertex_handle(h).idx())
		h = m.opposite_halfedge_handle(h);

	if (counter[h.idx()].touched == time)
		return;
	counter[h.idx()].isRemovedFromQueue = false;

	if (!m.is_flip_ok(m.edge_handle(h)))
		return;

	double energy = efun.delta_energy(m, h);
	counter[h.idx()].touched = time;

	const int avgValence = 6;
	if ((energy < 0) && (flipCounter[m.to_vertex_handle(h).idx()] < avgValence))
		Q.push(PQElement(energy, h, time));

}

void GELSmooth::add_one_ring_to_queue(const myMesh & m, std::vector<HalfEdgeCounter>& touched, std::priority_queue<PQElement>& Q, myMesh::VertexHandle v, const EnergyFun & efun, std::vector<int>& flipCounter, int time)
{
	for (myMesh::ConstVertexVertexIter vv_it = m.cvv_iter(v); vv_it.is_valid(); ++vv_it)
	{
		add_to_queue(m, touched, Q, m.halfedge_handle(v), efun, flipCounter, time);
	}
}

